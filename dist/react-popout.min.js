(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("react"), require("react-dom"));
	else if(typeof define === 'function' && define.amd)
		define(["react", "react-dom"], factory);
	else {
		var a = typeof exports === 'object' ? factory(require("react"), require("react-dom")) : factory(root["React"], root["ReactDOM"]);
		for(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];
	}
})(this, function(__WEBPACK_EXTERNAL_MODULE_2__, __WEBPACK_EXTERNAL_MODULE_3__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	module.exports = __webpack_require__(1);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	'use strict';

	Object.defineProperty(exports, "__esModule", {
	  value: true
	});

	var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

	var _react = __webpack_require__(2);

	var _react2 = _interopRequireDefault(_react);

	var _reactDom = __webpack_require__(3);

	var _reactDom2 = _interopRequireDefault(_reactDom);

	function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

	function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

	function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

	var _CONTAINER_ID = Symbol('container_id');
	var flatten = __webpack_require__(4);

	/**
	 * @class PopoutWindow
	 */

	var PopoutWindow = function (_React$Component) {
	  _inherits(PopoutWindow, _React$Component);

	  /**
	   * @constructs PoppoutWindow
	   * @param props
	   */
	  function PopoutWindow(props) {
	    _classCallCheck(this, PopoutWindow);

	    var _this = _possibleConstructorReturn(this, (PopoutWindow.__proto__ || Object.getPrototypeOf(PopoutWindow)).call(this, props));

	    _this.state = {
	      openedWindow: null
	    };
	    _this.defaultOptions = {
	      toolbar: 'no',
	      location: 'no',
	      directories: 'no',
	      status: 'no',
	      menubar: 'no',
	      scrollbars: 'yes',
	      resizable: 'yes',
	      width: 500,
	      height: 400,
	      top: function top(o, w) {
	        return (w.innerHeight - o.height) / 2 + w.screenY;
	      },
	      left: function left(o, w) {
	        return (w.innerWidth - o.width) / 2 + w.screenX;
	      }
	    };

	    _this[_CONTAINER_ID] = props.containerId || 'popout-content-container';
	    _this.closeWindow = _this.closeWindow.bind(_this);
	    return _this;
	  }

	  /**
	   * @type {{title: *, url: *, onClosing: *, options: *, window: *, containerId: *}}
	   */


	  _createClass(PopoutWindow, [{
	    key: 'run',
	    value: function run() {
	      var scripts = (this.state || {}).scripts || [];

	      var fns = scripts.map(function (src) {
	        return new Function('require', src);
	      }).forEach(function (fn) {
	        return fn();
	      });
	    }
	  }, {
	    key: 'findScripts',
	    value: function (_findScripts) {
	      function findScripts(_x) {
	        return _findScripts.apply(this, arguments);
	      }

	      findScripts.toString = function () {
	        return _findScripts.toString();
	      };

	      return findScripts;
	    }(function (node) {
	      if (node.tagName && node.tagName === 'script') {
	        return (node.childNodes || []).map(function (n) {
	          return n.value;
	        });
	      }

	      return flatten((node.childNodes || []).map(findScripts));
	    })

	    /**
	     * Override default id if we get given one
	     * @param props
	     */

	  }, {
	    key: 'componentWillReceiveProps',
	    value: function componentWillReceiveProps(props) {
	      props.containerId && (this[_CONTAINER_ID] = props.containerId);
	    }
	  }, {
	    key: 'componentWillUnmount',
	    value: function componentWillUnmount() {
	      this.closeWindow();
	    }
	  }, {
	    key: 'componentDidMount',
	    value: function componentDidMount() {
	      var _this2 = this;

	      var popoutWindow = void 0,
	          container = void 0;

	      var options = Object.assign({}, this.defaultOptions, this.props.options),
	          ownerWindow = this.props.window || window,
	          openedWindow = {
	        update: function update(newComponent) {
	          _reactDom2.default.render(newComponent, container);
	        },
	        close: function close() {
	          popoutWindow && popoutWindow.close();
	        }
	      };
	      this.setState({ scripts: this.findScripts(this.props.children) }, function () {
	        return _this2.run();
	      });

	      if (!ownerWindow) {
	        // If we have no owner windows, bail. Likely server side render
	        return;
	      }

	      var createOptions = function createOptions() {
	        var ret = [];
	        for (var key in options) {
	          options.hasOwnProperty(key) && ret.push(key + '=' + (typeof options[key] === 'function' ? options[key].call(_this2, options, ownerWindow) : options[key]));
	        }
	        return ret.join(',');
	      };

	      popoutWindow = ownerWindow.open(this.props.url || 'about:blank', this.props.title, createOptions());

	      popoutWindow.onbeforeunload = function () {
	        container && _reactDom2.default.unmountComponentAtNode(container);
	        _this2.windowClosing();
	      };
	      // Close any open popouts when page unloads/refeshes
	      ownerWindow.addEventListener('unload', this.closeWindow);

	      var onloadHandler = function onloadHandler() {
	        if (container) {
	          if (popoutWindow.document.getElementById(_this2[_CONTAINER_ID])) return;

	          _reactDom2.default.unmountComponentAtNode(container);
	          container = null;
	        }

	        popoutWindow.document.title = _this2.props.title;
	        container = popoutWindow.document.createElement('div');
	        container.id = _this2[_CONTAINER_ID];
	        popoutWindow.document.body.appendChild(container);

	        _reactDom2.default.render(_this2.props.children, container);
	      };

	      popoutWindow.onload = onloadHandler;
	      // Just in case that onload doesn't fire / has fired already, we call it manually if it's ready.
	      popoutWindow.document.readyState === 'complete' && onloadHandler();

	      this.setState({ openedWindow: openedWindow });
	    }
	  }, {
	    key: 'closeWindow',
	    value: function closeWindow() {
	      this.state.openedWindow && this.state.openedWindow.close();
	      (this.props.window || window).removeEventListener('unload', this.closeWindow);
	    }
	  }, {
	    key: 'windowClosing',
	    value: function windowClosing() {
	      this.props.onClosing && this.props.onClosing();
	    }

	    /**
	     * Bubble changes
	     */

	  }, {
	    key: 'componentDidUpdate',
	    value: function componentDidUpdate() {
	      // For SSR we might get updated but there will be no openedWindow. Make sure openedWIndow exists before calling
	      this.state.openedWindow && this.state.openedWindow.update(this.props.children);
	    }
	  }, {
	    key: 'render',
	    value: function render() {
	      return _react2.default.createElement('div', null);
	    }
	  }]);

	  return PopoutWindow;
	}(_react2.default.Component);

	PopoutWindow.propTypes = {
	  title: _react2.default.PropTypes.string.isRequired,
	  url: _react2.default.PropTypes.string,
	  onClosing: _react2.default.PropTypes.func,
	  options: _react2.default.PropTypes.object,
	  window: _react2.default.PropTypes.object,
	  containerId: _react2.default.PropTypes.string,
	  children: _react2.default.PropTypes.element
	};
	exports.default = PopoutWindow;

/***/ },
/* 2 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_2__;

/***/ },
/* 3 */
/***/ function(module, exports) {

	module.exports = __WEBPACK_EXTERNAL_MODULE_3__;

/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	var baseFlatten = __webpack_require__(5);

	/**
	 * Flattens `array` a single level deep.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Array
	 * @param {Array} array The array to flatten.
	 * @returns {Array} Returns the new flattened array.
	 * @example
	 *
	 * _.flatten([1, [2, [3, [4]], 5]]);
	 * // => [1, 2, [3, [4]], 5]
	 */
	function flatten(array) {
	  var length = array == null ? 0 : array.length;
	  return length ? baseFlatten(array, 1) : [];
	}

	module.exports = flatten;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	var arrayPush = __webpack_require__(6),
	    isFlattenable = __webpack_require__(7);

	/**
	 * The base implementation of `_.flatten` with support for restricting flattening.
	 *
	 * @private
	 * @param {Array} array The array to flatten.
	 * @param {number} depth The maximum recursion depth.
	 * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
	 * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
	 * @param {Array} [result=[]] The initial result value.
	 * @returns {Array} Returns the new flattened array.
	 */
	function baseFlatten(array, depth, predicate, isStrict, result) {
	  var index = -1,
	      length = array.length;

	  predicate || (predicate = isFlattenable);
	  result || (result = []);

	  while (++index < length) {
	    var value = array[index];
	    if (depth > 0 && predicate(value)) {
	      if (depth > 1) {
	        // Recursively flatten arrays (susceptible to call stack limits).
	        baseFlatten(value, depth - 1, predicate, isStrict, result);
	      } else {
	        arrayPush(result, value);
	      }
	    } else if (!isStrict) {
	      result[result.length] = value;
	    }
	  }
	  return result;
	}

	module.exports = baseFlatten;


/***/ },
/* 6 */
/***/ function(module, exports) {

	/**
	 * Appends the elements of `values` to `array`.
	 *
	 * @private
	 * @param {Array} array The array to modify.
	 * @param {Array} values The values to append.
	 * @returns {Array} Returns `array`.
	 */
	function arrayPush(array, values) {
	  var index = -1,
	      length = values.length,
	      offset = array.length;

	  while (++index < length) {
	    array[offset + index] = values[index];
	  }
	  return array;
	}

	module.exports = arrayPush;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(8),
	    isArguments = __webpack_require__(11),
	    isArray = __webpack_require__(17);

	/** Built-in value references. */
	var spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined;

	/**
	 * Checks if `value` is a flattenable `arguments` object or array.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
	 */
	function isFlattenable(value) {
	  return isArray(value) || isArguments(value) ||
	    !!(spreadableSymbol && value && value[spreadableSymbol]);
	}

	module.exports = isFlattenable;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	var root = __webpack_require__(9);

	/** Built-in value references. */
	var Symbol = root.Symbol;

	module.exports = Symbol;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	var freeGlobal = __webpack_require__(10);

	/** Detect free variable `self`. */
	var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

	/** Used as a reference to the global object. */
	var root = freeGlobal || freeSelf || Function('return this')();

	module.exports = root;


/***/ },
/* 10 */
/***/ function(module, exports) {

	/* WEBPACK VAR INJECTION */(function(global) {/** Detect free variable `global` from Node.js. */
	var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

	module.exports = freeGlobal;

	/* WEBPACK VAR INJECTION */}.call(exports, (function() { return this; }())))

/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

	var baseIsArguments = __webpack_require__(12),
	    isObjectLike = __webpack_require__(16);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/** Built-in value references. */
	var propertyIsEnumerable = objectProto.propertyIsEnumerable;

	/**
	 * Checks if `value` is likely an `arguments` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 *  else `false`.
	 * @example
	 *
	 * _.isArguments(function() { return arguments; }());
	 * // => true
	 *
	 * _.isArguments([1, 2, 3]);
	 * // => false
	 */
	var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
	  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
	    !propertyIsEnumerable.call(value, 'callee');
	};

	module.exports = isArguments;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	var baseGetTag = __webpack_require__(13),
	    isObjectLike = __webpack_require__(16);

	/** `Object#toString` result references. */
	var argsTag = '[object Arguments]';

	/**
	 * The base implementation of `_.isArguments`.
	 *
	 * @private
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
	 */
	function baseIsArguments(value) {
	  return isObjectLike(value) && baseGetTag(value) == argsTag;
	}

	module.exports = baseIsArguments;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(8),
	    getRawTag = __webpack_require__(14),
	    objectToString = __webpack_require__(15);

	/** `Object#toString` result references. */
	var nullTag = '[object Null]',
	    undefinedTag = '[object Undefined]';

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * The base implementation of `getTag` without fallbacks for buggy environments.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the `toStringTag`.
	 */
	function baseGetTag(value) {
	  if (value == null) {
	    return value === undefined ? undefinedTag : nullTag;
	  }
	  return (symToStringTag && symToStringTag in Object(value))
	    ? getRawTag(value)
	    : objectToString(value);
	}

	module.exports = baseGetTag;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	var Symbol = __webpack_require__(8);

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/** Used to check objects for own properties. */
	var hasOwnProperty = objectProto.hasOwnProperty;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/** Built-in value references. */
	var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

	/**
	 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
	 *
	 * @private
	 * @param {*} value The value to query.
	 * @returns {string} Returns the raw `toStringTag`.
	 */
	function getRawTag(value) {
	  var isOwn = hasOwnProperty.call(value, symToStringTag),
	      tag = value[symToStringTag];

	  try {
	    value[symToStringTag] = undefined;
	    var unmasked = true;
	  } catch (e) {}

	  var result = nativeObjectToString.call(value);
	  if (unmasked) {
	    if (isOwn) {
	      value[symToStringTag] = tag;
	    } else {
	      delete value[symToStringTag];
	    }
	  }
	  return result;
	}

	module.exports = getRawTag;


/***/ },
/* 15 */
/***/ function(module, exports) {

	/** Used for built-in method references. */
	var objectProto = Object.prototype;

	/**
	 * Used to resolve the
	 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
	 * of values.
	 */
	var nativeObjectToString = objectProto.toString;

	/**
	 * Converts `value` to a string using `Object.prototype.toString`.
	 *
	 * @private
	 * @param {*} value The value to convert.
	 * @returns {string} Returns the converted string.
	 */
	function objectToString(value) {
	  return nativeObjectToString.call(value);
	}

	module.exports = objectToString;


/***/ },
/* 16 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is object-like. A value is object-like if it's not `null`
	 * and has a `typeof` result of "object".
	 *
	 * @static
	 * @memberOf _
	 * @since 4.0.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
	 * @example
	 *
	 * _.isObjectLike({});
	 * // => true
	 *
	 * _.isObjectLike([1, 2, 3]);
	 * // => true
	 *
	 * _.isObjectLike(_.noop);
	 * // => false
	 *
	 * _.isObjectLike(null);
	 * // => false
	 */
	function isObjectLike(value) {
	  return value != null && typeof value == 'object';
	}

	module.exports = isObjectLike;


/***/ },
/* 17 */
/***/ function(module, exports) {

	/**
	 * Checks if `value` is classified as an `Array` object.
	 *
	 * @static
	 * @memberOf _
	 * @since 0.1.0
	 * @category Lang
	 * @param {*} value The value to check.
	 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
	 * @example
	 *
	 * _.isArray([1, 2, 3]);
	 * // => true
	 *
	 * _.isArray(document.body.children);
	 * // => false
	 *
	 * _.isArray('abc');
	 * // => false
	 *
	 * _.isArray(_.noop);
	 * // => false
	 */
	var isArray = Array.isArray;

	module.exports = isArray;


/***/ }
/******/ ])
});
;